# -*- coding: utf-8 -*-
"""Taco_TimeSeries.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cdmwWR5SeZmjUOkF-5IpEKzf_BGBULj0
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import SimpleRNN, Dense
from sklearn.preprocessing import MinMaxScaler
from IPython.display import display, Markdown
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Load dataset and group daily taco orders
df = pd.read_csv("taco_sales_(2024-2025).csv")
df['Order Time'] = pd.to_datetime(df['Order Time'], dayfirst=True)
df['Order Date'] = df['Order Time'].dt.date

# Group by date and count orders
daily_orders = df.groupby('Order Date').size().reset_index(name='Order Count')

# Add 'day-of-week' feature to evaluate "Taco Tuesday" profitability (0 = Monday, 6 = Sunday)
daily_orders['Day of the Week'] = pd.to_datetime(daily_orders['Order Date']).dt.dayofweek

# Normalize both features
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(daily_orders[['Order Count', 'Day of the Week']])

n_input = 31 # Use past 31 days (1 month) for each prediction
X, y = [], []

for i in range(len(scaled_data) - n_input):
  X.append(scaled_data[i:i+n_input])
  y.append(scaled_data[i+n_input][0])

X = np.array(X)
y = np.array(y)

# Reshape input
print("Input shape:", X.shape)

# Build RNN model
model = Sequential()
model.add(SimpleRNN(50, activation='relu', input_shape=(n_input, 2)))
model.add(Dense(1))

# Compile and train
model.compile(optimizer='adam', loss='mse')
model.fit(X, y, epochs=50, verbose=1)

# Use the most recent 31 days to predict the next day
last_seq = scaled_data[-n_input:]
last_seq = last_seq.reshape((1, n_input, 2))
next_day_scaled = model.predict(last_seq)

# Inverse transformation
pad = np.array([[0]])
next_day_full = np.hstack([next_day_scaled, pad])
next_day_forecast = scaler.inverse_transform(next_day_full)[0][0]

print(f"Predicted taco orders for next day: {next_day_forecast:.2f}")

"""##**Final Model Evaluation**##"""

# Predict over training data
y_pred = model.predict(X)

pad = np.zeros_like(y_pred)
y_pred_full = np.hstack([y_pred, pad])
y_actual_full = np.hstack([y.reshape(-1,1), pad])

# Inverse scale both
y_pred_rescaled = scaler.inverse_transform(y_pred_full)[:, 0]
y_actual_rescaled = scaler.inverse_transform(y_actual_full)[:, 0]

# Plot actual vs predicted
plt.figure(figsize=(12, 4))
plt.plot(y_actual_rescaled, label="Actual", color="blue")
plt.plot(y_pred_rescaled, label="Predicted", color="orange")
plt.title("RNN Predictions vs Actual Taco Sales")
plt.xlabel("Day Index")
plt.ylabel("Order Count")
plt.legend()
plt.tight_layout()
plt.show()

mae = mean_absolute_error(y_actual_rescaled, y_pred_rescaled)
rmse = np.sqrt(mean_squared_error(y_actual_rescaled, y_pred_rescaled))

print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")

# Calculate average order count per day of the week
weekday_avg = daily_orders.groupby('Day of the Week')['Order Count'].mean().reset_index()
weekday_labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
weekday_avg['Day'] = weekday_avg['Day of the Week'].apply(lambda x: weekday_labels[x])
weekday_avg = weekday_avg[['Day', 'Order Count']]
weekday_avg = weekday_avg.rename(columns={'Order Count': 'Average Orders'})
weekday_avg = weekday_avg.round(2)

# Calculate mean order count in a single day
mean_value = daily_orders['Order Count'].mean()

# Display results
display(weekday_avg)
print(f"\nMean Order Count: {mean_value:.2f}")